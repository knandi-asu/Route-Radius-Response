import {
  require_react_dom
} from "./chunk-MRMTFEGN.js";
import {
  require_react
} from "./chunk-TGKAJP7Z.js";
import {
  __toESM
} from "./chunk-LQ2VYIYD.js";

// node_modules/@reach/combobox/dist/reach-combobox.mjs
var React7 = __toESM(require_react(), 1);

// node_modules/@reach/utils/dist/reach-utils.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var React = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_react9 = __toESM(require_react(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);
var import_react13 = __toESM(require_react(), 1);
var import_react14 = __toESM(require_react(), 1);
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      return ourHandler(event);
    }
  };
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isFunction(value) {
  return !!(value && {}.toString.call(value) == "[object Function]");
}
function assignRef(ref, value) {
  if (ref == null)
    return;
  if (isFunction(ref)) {
    ref(value);
  } else {
    try {
      ref.current = value;
    } catch (error) {
      throw new Error(`Cannot assign value "${value}" to ref "${ref}"`);
    }
  }
}
function useComposedRefs(...refs) {
  return (0, import_react2.useCallback)((node) => {
    for (let ref of refs) {
      assignRef(ref, node);
    }
  }, refs);
}
function getOwnerDocument(element) {
  return canUseDOM() ? element ? element.ownerDocument : document : null;
}
function createNamedContext(name, defaultValue) {
  let Ctx = React.createContext(defaultValue);
  Ctx.displayName = name;
  return Ctx;
}
function makeId(...args) {
  return args.filter((val) => val != null).join("--");
}
function noop() {
}
function useForceUpdate() {
  let [, dispatch] = (0, import_react8.useState)(/* @__PURE__ */ Object.create(null));
  return (0, import_react8.useCallback)(() => {
    dispatch(/* @__PURE__ */ Object.create(null));
  }, []);
}
var useIsomorphicLayoutEffect = canUseDOM() ? import_react9.useLayoutEffect : import_react9.useEffect;
function useStatefulRefValue(ref, initialState) {
  let [state, setState] = (0, import_react13.useState)(initialState);
  let callbackRef = (0, import_react13.useCallback)((refValue) => {
    ref.current = refValue;
    setState(refValue);
  }, []);
  return [state, callbackRef];
}
function useUpdateEffect(effect, deps) {
  const mounted = (0, import_react14.useRef)(false);
  (0, import_react14.useEffect)(() => {
    if (mounted.current) {
      effect();
    } else {
      mounted.current = true;
    }
  }, deps);
}

// node_modules/@reach/descendants/dist/reach-descendants.mjs
var React2 = __toESM(require_react(), 1);
function createDescendantContext(name, initialValue = {}) {
  const descendants = [];
  let ctx = React2.createContext({
    descendants,
    registerDescendant: () => noop,
    ...initialValue
  });
  ctx.displayName = name;
  return ctx;
}
function useDescendant(descendant, context, indexProp) {
  let forceUpdate = useForceUpdate();
  let { registerDescendant, descendants } = React2.useContext(context);
  let index = indexProp ?? descendants.findIndex((item) => item.element === descendant.element);
  useIsomorphicLayoutEffect(() => {
    if (!descendant.element)
      forceUpdate();
    return registerDescendant({ ...descendant, index });
  }, [
    descendant,
    forceUpdate,
    index,
    registerDescendant,
    ...Object.values(descendant)
  ]);
  return index;
}
function useDescendantsInit() {
  return React2.useState([]);
}
function useDescendants(ctx) {
  return React2.useContext(ctx).descendants;
}
function DescendantProvider({
  context: Ctx,
  children,
  items,
  set
}) {
  let registerDescendant = React2.useCallback(({
    element,
    index: explicitIndex,
    ...rest
  }) => {
    if (!element)
      return noop;
    set((items2) => {
      if (explicitIndex != null && explicitIndex !== -1) {
        return insertAt(items2, { element, index: explicitIndex, ...rest }, explicitIndex);
      }
      if (items2.length === 0) {
        return [{ ...rest, element, index: 0 }];
      }
      if (true) {
        if (items2.find((item) => item.element === element)) {
          console.warn("[reach-ui]: `useDescendant` was called with an element that was already registered.\n\nIf you are using the `@reach/descendants` package directly, make sure to only register descendants once. Registering a descendant more than once will lead to bugs in your app.\n\nIf you are using another `reach-ui` package, this is probably our bug!\n\nTo report a bug, open a new issue:\n\n  https://github.com/reach/reach-ui/issues/new?assignees=&labels=&template=Bug_report.md\n\nIMPORTANT: this check will only run in the development build, so if you see this warning please be aware that your app may crash when deployed.");
          return updateIndices(items2);
        }
      }
      let index = findDOMIndex(items2, element);
      let newItems;
      if (index === -1) {
        newItems = [
          ...items2,
          { ...rest, element, index: items2.length }
        ];
      } else {
        newItems = insertAt(items2, { ...rest, element, index }, index);
      }
      return newItems;
    });
    return () => {
      if (!element)
        return;
      set((items2) => items2.filter((item) => element !== item.element));
    };
  }, []);
  return React2.createElement(Ctx.Provider, {
    value: React2.useMemo(() => {
      return {
        descendants: items,
        registerDescendant
      };
    }, [items, registerDescendant])
  }, children);
}
function isElementPreceding(a, b) {
  return Boolean(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);
}
function findDOMIndex(items, element) {
  if (!element)
    return -1;
  if (!items.length)
    return -1;
  let length = items.length;
  while (length--) {
    let currentElement = items[length].element;
    if (!currentElement)
      continue;
    if (isElementPreceding(currentElement, element)) {
      return length + 1;
    }
  }
  return -1;
}
function insertAt(array, item, index) {
  if (index == null || !(index in array)) {
    return [...array, item];
  }
  return [...array.slice(0, index), item, ...array.slice(index)];
}
function updateIndices(items) {
  return items.sort((a, b) => !a.element || !b.element ? 0 : isElementPreceding(a.element, b.element) ? -1 : 1).map((item, index) => ({ ...item, index }));
}

// node_modules/@reach/auto-id/dist/reach-auto-id.mjs
var React3 = __toESM(require_react(), 1);
var serverHandoffComplete = false;
var id = 0;
function genId() {
  return ++id;
}
var maybeReactUseId = React3["useId".toString()];
function useId(providedId) {
  if (maybeReactUseId !== void 0) {
    let generatedId = maybeReactUseId();
    return providedId ?? generatedId;
  }
  let initialId = providedId ?? (serverHandoffComplete ? genId() : null);
  let [id2, setId] = React3.useState(initialId);
  useIsomorphicLayoutEffect(() => {
    if (id2 === null) {
      setId(genId());
    }
  }, []);
  React3.useEffect(() => {
    if (serverHandoffComplete === false) {
      serverHandoffComplete = true;
    }
  }, []);
  return providedId ?? id2 ?? void 0;
}

// node_modules/@reach/popover/dist/reach-popover.mjs
var React6 = __toESM(require_react(), 1);

// node_modules/@reach/portal/dist/reach-portal.mjs
var React4 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var PortalImpl = ({
  children,
  type = "reach-portal",
  containerRef
}) => {
  let mountNode = React4.useRef(null);
  let portalNode = React4.useRef(null);
  let forceUpdate = useForceUpdate();
  if (true) {
    React4.useEffect(() => {
      if (containerRef != null) {
        if (typeof containerRef !== "object" || !("current" in containerRef)) {
          console.warn("@reach/portal: Invalid value passed to the `containerRef` of a `Portal`. The portal will be appended to the document body, but if you want to attach it to another DOM node you must pass a valid React ref object to `containerRef`.");
        } else if (containerRef.current == null) {
          console.warn("@reach/portal: A ref was passed to the `containerRef` prop of a `Portal`, but no DOM node was attached to it. Be sure to pass the ref to a DOM component.\n\nIf you are forwarding the ref from another component, be sure to use the React.forwardRef API. See https://reactjs.org/docs/forwarding-refs.html.");
        }
      }
    }, [containerRef]);
  }
  useIsomorphicLayoutEffect(() => {
    if (!mountNode.current)
      return;
    let ownerDocument = mountNode.current.ownerDocument;
    let body = (containerRef == null ? void 0 : containerRef.current) || ownerDocument.body;
    portalNode.current = ownerDocument == null ? void 0 : ownerDocument.createElement(type);
    body.appendChild(portalNode.current);
    forceUpdate();
    return () => {
      if (portalNode.current && body) {
        body.removeChild(portalNode.current);
      }
    };
  }, [type, forceUpdate, containerRef]);
  return portalNode.current ? (0, import_react_dom.createPortal)(children, portalNode.current) : React4.createElement("span", {
    ref: mountNode
  });
};
var Portal = ({
  unstable_skipInitialRender,
  ...props2
}) => {
  let [hydrated, setHydrated] = React4.useState(false);
  React4.useEffect(() => {
    if (unstable_skipInitialRender) {
      setHydrated(true);
    }
  }, [unstable_skipInitialRender]);
  if (unstable_skipInitialRender && !hydrated) {
    return null;
  }
  return React4.createElement(PortalImpl, {
    ...props2
  });
};
Portal.displayName = "Portal";

// node_modules/@reach/rect/dist/reach-rect.mjs
var React5 = __toESM(require_react(), 1);

// node_modules/@reach/observe-rect/dist/observe-rect.esm.js
var props = ["bottom", "height", "left", "right", "top", "width"];
var rectChanged = function rectChanged2(a, b) {
  if (a === void 0) {
    a = {};
  }
  if (b === void 0) {
    b = {};
  }
  return props.some(function(prop) {
    return a[prop] !== b[prop];
  });
};
var observedNodes = /* @__PURE__ */ new Map();
var rafId;
var run = function run2() {
  var changedStates = [];
  observedNodes.forEach(function(state, node) {
    var newRect = node.getBoundingClientRect();
    if (rectChanged(newRect, state.rect)) {
      state.rect = newRect;
      changedStates.push(state);
    }
  });
  changedStates.forEach(function(state) {
    state.callbacks.forEach(function(cb) {
      return cb(state.rect);
    });
  });
  rafId = window.requestAnimationFrame(run2);
};
function observeRect(node, cb) {
  return {
    observe: function observe() {
      var wasEmpty = observedNodes.size === 0;
      if (observedNodes.has(node)) {
        observedNodes.get(node).callbacks.push(cb);
      } else {
        observedNodes.set(node, {
          rect: void 0,
          hasRectChanged: false,
          callbacks: [cb]
        });
      }
      if (wasEmpty)
        run();
    },
    unobserve: function unobserve() {
      var state = observedNodes.get(node);
      if (state) {
        var index = state.callbacks.indexOf(cb);
        if (index >= 0)
          state.callbacks.splice(index, 1);
        if (!state.callbacks.length)
          observedNodes["delete"](node);
        if (!observedNodes.size)
          cancelAnimationFrame(rafId);
      }
    }
  };
}
var observe_rect_esm_default = observeRect;

// node_modules/@reach/rect/dist/reach-rect.mjs
var Rect = ({ onChange, observe = true, children }) => {
  const ref = React5.useRef(null);
  const rect = useRect(ref, { observe, onChange });
  return children({ ref, rect });
};
Rect.displayName = "Rect";
function useRect(nodeRef, observeOrOptions, deprecated_onChange) {
  let observe;
  let onChange;
  if (isBoolean(observeOrOptions)) {
    observe = observeOrOptions;
  } else {
    observe = (observeOrOptions == null ? void 0 : observeOrOptions.observe) ?? true;
    onChange = observeOrOptions == null ? void 0 : observeOrOptions.onChange;
  }
  if (isFunction(deprecated_onChange)) {
    onChange = deprecated_onChange;
  }
  if (true) {
    React5.useEffect(() => {
      if (isBoolean(observeOrOptions)) {
        console.warn("Passing `observe` as the second argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `observe` property as the second argument (`useRect(ref, { observe })`).\nSee https://reach.tech/rect#userect-observe");
      }
    }, [observeOrOptions]);
    React5.useEffect(() => {
      if (isFunction(deprecated_onChange)) {
        console.warn("Passing `onChange` as the third argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `onChange` property as the second argument (`useRect(ref, { onChange })`).\nSee https://reach.tech/rect#userect-onchange");
      }
    }, [deprecated_onChange]);
  }
  let [element, setElement] = React5.useState(nodeRef.current);
  let initialRectIsSet = React5.useRef(false);
  let initialRefIsSet = React5.useRef(false);
  let [rect, setRect] = React5.useState(null);
  let onChangeRef = React5.useRef(onChange);
  useIsomorphicLayoutEffect(() => {
    onChangeRef.current = onChange;
    if (nodeRef.current !== element) {
      setElement(nodeRef.current);
    }
  });
  useIsomorphicLayoutEffect(() => {
    if (element && !initialRectIsSet.current) {
      initialRectIsSet.current = true;
      setRect(element.getBoundingClientRect());
    }
  }, [element]);
  useIsomorphicLayoutEffect(() => {
    if (!observe) {
      return;
    }
    let elem = element;
    if (!initialRefIsSet.current) {
      initialRefIsSet.current = true;
      elem = nodeRef.current;
    }
    if (!elem) {
      if (true) {
        console.warn("You need to place the ref");
      }
      return;
    }
    let observer = observe_rect_esm_default(elem, (rect2) => {
      var _a;
      (_a = onChangeRef.current) == null ? void 0 : _a.call(onChangeRef, rect2);
      setRect(rect2);
    });
    observer.observe();
    return () => {
      observer.unobserve();
    };
  }, [observe, element, nodeRef]);
  return rect;
}

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  return element.getRootNode();
} : function(element) {
  return element.ownerDocument;
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scope: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scope: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var getTabindex = function getTabindex2(node, isScope) {
  if (node.tabIndex < 0) {
    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
      return 0;
    }
  }
  return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  var nodeRootHost = getRootNode(node).host;
  var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
  if (!displayCheck || displayCheck === "full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (nodeIsAttached) {
      return !node.getClientRects().length;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i) {
    var isScope = !!item.scope;
    var element = isScope ? item.scope : item;
    var candidateTabindex = getTabindex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");

// node_modules/@reach/popover/dist/reach-popover.mjs
var Popover = React6.forwardRef(function Popover2({ unstable_skipInitialPortalRender, ...props2 }, ref) {
  return React6.createElement(Portal, {
    unstable_skipInitialRender: unstable_skipInitialPortalRender
  }, React6.createElement(PopoverImpl, {
    ref,
    ...props2
  }));
});
Popover.displayName = "Popover";
var PopoverImpl = React6.forwardRef(function PopoverImpl2({
  as: Comp = "div",
  targetRef,
  position = positionDefault,
  unstable_observableRefs = [],
  ...props2
}, forwardedRef) {
  const popoverRef = React6.useRef(null);
  const popoverRect = useRect(popoverRef, { observe: !props2.hidden });
  const targetRect = useRect(targetRef, { observe: true });
  const ref = useComposedRefs(popoverRef, forwardedRef);
  useSimulateTabNavigationForReactTree(targetRef, popoverRef);
  return React6.createElement(Comp, {
    "data-reach-popover": "",
    ref,
    ...props2,
    style: {
      position: "absolute",
      ...getStyles(position, targetRect, popoverRect, ...unstable_observableRefs),
      ...props2.style
    }
  });
});
PopoverImpl.displayName = "PopoverImpl";
function getStyles(position, targetRect, popoverRect, ...unstable_observableRefs) {
  return popoverRect ? position(targetRect, popoverRect, ...unstable_observableRefs.map((ref) => ref.current)) : { visibility: "hidden" };
}
function getTopPosition(targetRect, popoverRect, isDirectionUp) {
  return {
    top: isDirectionUp ? `${targetRect.top - popoverRect.height + window.pageYOffset}px` : `${targetRect.top + targetRect.height + window.pageYOffset}px`
  };
}
var positionDefault = (targetRect, popoverRect) => {
  if (!targetRect || !popoverRect) {
    return {};
  }
  const { directionRight, directionUp } = getCollisions(targetRect, popoverRect);
  return {
    left: directionRight ? `${targetRect.right - popoverRect.width + window.pageXOffset}px` : `${targetRect.left + window.pageXOffset}px`,
    ...getTopPosition(targetRect, popoverRect, directionUp)
  };
};
var positionMatchWidth = (targetRect, popoverRect) => {
  if (!targetRect || !popoverRect) {
    return {};
  }
  const { directionUp } = getCollisions(targetRect, popoverRect);
  return {
    width: targetRect.width,
    left: targetRect.left,
    ...getTopPosition(targetRect, popoverRect, directionUp)
  };
};
function getCollisions(targetRect, popoverRect, offsetLeft = 0, offsetBottom = 0) {
  const collisions = {
    top: targetRect.top - popoverRect.height < 0,
    right: window.innerWidth < targetRect.left + popoverRect.width - offsetLeft,
    bottom: window.innerHeight < targetRect.bottom + popoverRect.height - offsetBottom,
    left: targetRect.left + targetRect.width - popoverRect.width < 0
  };
  const directionRight = collisions.right && !collisions.left;
  const directionLeft = collisions.left && !collisions.right;
  const directionUp = collisions.bottom && !collisions.top;
  const directionDown = collisions.top && !collisions.bottom;
  return { directionRight, directionLeft, directionUp, directionDown };
}
function useSimulateTabNavigationForReactTree(triggerRef, popoverRef) {
  const ownerDocument = getOwnerDocument(triggerRef.current);
  function handleKeyDown(event) {
    if (event.key === "Tab" && popoverRef.current && tabbable(popoverRef.current).length === 0) {
      return;
    }
    if (event.key === "Tab" && event.shiftKey) {
      if (shiftTabbedFromElementAfterTrigger(event)) {
        focusLastTabbableInPopover(event);
      } else if (shiftTabbedOutOfPopover(event)) {
        focusTriggerRef(event);
      } else if (shiftTabbedToBrowserChrome(event)) {
        disableTabbablesInPopover();
      }
    } else if (event.key === "Tab") {
      if (tabbedFromTriggerToPopover()) {
        focusFirstPopoverTabbable(event);
      } else if (tabbedOutOfPopover()) {
        focusTabbableAfterTrigger(event);
      } else if (tabbedToBrowserChrome(event)) {
        disableTabbablesInPopover();
      }
    }
  }
  React6.useEffect(() => {
    ownerDocument.addEventListener("keydown", handleKeyDown);
    return () => {
      ownerDocument.removeEventListener("keydown", handleKeyDown);
    };
  }, []);
  function getElementAfterTrigger() {
    const elements = tabbable(ownerDocument);
    const targetIndex = elements && triggerRef.current ? elements.indexOf(triggerRef.current) : -1;
    const elementAfterTrigger = elements && elements[targetIndex + 1];
    return popoverRef.current && popoverRef.current.contains(elementAfterTrigger || null) ? false : elementAfterTrigger;
  }
  function tabbedFromTriggerToPopover() {
    return triggerRef.current ? triggerRef.current === ownerDocument.activeElement : false;
  }
  function focusFirstPopoverTabbable(event) {
    const elements = popoverRef.current && tabbable(popoverRef.current);
    if (elements && elements[0]) {
      event.preventDefault();
      elements[0].focus();
    }
  }
  function tabbedOutOfPopover() {
    const inPopover = popoverRef.current ? popoverRef.current.contains(ownerDocument.activeElement || null) : false;
    if (inPopover) {
      const elements = popoverRef.current && tabbable(popoverRef.current);
      return Boolean(elements && elements[elements.length - 1] === ownerDocument.activeElement);
    }
    return false;
  }
  function focusTabbableAfterTrigger(event) {
    const elementAfterTrigger = getElementAfterTrigger();
    if (elementAfterTrigger) {
      event.preventDefault();
      elementAfterTrigger.focus();
    }
  }
  function shiftTabbedFromElementAfterTrigger(event) {
    if (!event.shiftKey)
      return;
    const elementAfterTrigger = getElementAfterTrigger();
    return event.target === elementAfterTrigger;
  }
  function focusLastTabbableInPopover(event) {
    const elements = popoverRef.current && tabbable(popoverRef.current);
    const last = elements && elements[elements.length - 1];
    if (last) {
      event.preventDefault();
      last.focus();
    }
  }
  function shiftTabbedOutOfPopover(event) {
    const elements = popoverRef.current && tabbable(popoverRef.current);
    if (elements) {
      return elements.length === 0 ? false : event.target === elements[0];
    }
    return false;
  }
  function focusTriggerRef(event) {
    var _a;
    event.preventDefault();
    (_a = triggerRef.current) == null ? void 0 : _a.focus();
  }
  function tabbedToBrowserChrome(event) {
    const elements = popoverRef.current ? tabbable(ownerDocument).filter((element) => !popoverRef.current.contains(element)) : null;
    return elements ? event.target === elements[elements.length - 1] : false;
  }
  function shiftTabbedToBrowserChrome(event) {
    return event.target === tabbable(ownerDocument)[0];
  }
  let restoreTabIndexTuplés = [];
  function disableTabbablesInPopover() {
    const elements = popoverRef.current && tabbable(popoverRef.current);
    if (elements) {
      elements.forEach((element) => {
        restoreTabIndexTuplés.push([element, element.tabIndex]);
        element.tabIndex = -1;
      });
      ownerDocument.addEventListener("focusin", enableTabbablesInPopover);
    }
  }
  function enableTabbablesInPopover() {
    ownerDocument.removeEventListener("focusin", enableTabbablesInPopover);
    restoreTabIndexTuplés.forEach(([element, tabIndex]) => {
      element.tabIndex = tabIndex;
    });
  }
}

// node_modules/@reach/combobox/dist/reach-combobox.mjs
function findAll({
  autoEscape,
  caseSensitive = false,
  findChunks = defaultFindChunks,
  sanitize,
  searchWords,
  textToHighlight
}) {
  return fillInChunks({
    chunksToHighlight: combineChunks({
      chunks: findChunks({
        autoEscape,
        caseSensitive,
        sanitize,
        searchWords,
        textToHighlight
      })
    }),
    totalLength: textToHighlight ? textToHighlight.length : 0
  });
}
function combineChunks({ chunks }) {
  return chunks.sort((first, second) => first.start - second.start).reduce((processedChunks, nextChunk) => {
    if (processedChunks.length === 0) {
      return [nextChunk];
    } else {
      const prevChunk = processedChunks.pop();
      if (nextChunk.start <= prevChunk.end) {
        const endIndex = Math.max(prevChunk.end, nextChunk.end);
        processedChunks.push({
          highlight: false,
          start: prevChunk.start,
          end: endIndex
        });
      } else {
        processedChunks.push(prevChunk, nextChunk);
      }
      return processedChunks;
    }
  }, []);
}
function defaultFindChunks({
  autoEscape,
  caseSensitive,
  sanitize = defaultSanitize,
  searchWords,
  textToHighlight
}) {
  textToHighlight = sanitize(textToHighlight || "");
  return searchWords.filter((searchWord) => searchWord).reduce((chunks, searchWord) => {
    searchWord = sanitize(searchWord);
    if (autoEscape) {
      searchWord = escapeRegExpFn(searchWord);
    }
    const regex = new RegExp(searchWord, caseSensitive ? "g" : "gi");
    let match;
    while (match = regex.exec(textToHighlight || "")) {
      let start = match.index;
      let end = regex.lastIndex;
      if (end > start) {
        chunks.push({ highlight: false, start, end });
      }
      if (match.index === regex.lastIndex) {
        regex.lastIndex++;
      }
    }
    return chunks;
  }, []);
}
function fillInChunks({
  chunksToHighlight,
  totalLength
}) {
  const allChunks = [];
  if (chunksToHighlight.length === 0) {
    append(0, totalLength, false);
  } else {
    let lastIndex = 0;
    chunksToHighlight.forEach((chunk) => {
      append(lastIndex, chunk.start, false);
      append(chunk.start, chunk.end, true);
      lastIndex = chunk.end;
    });
    append(lastIndex, totalLength, false);
  }
  return allChunks;
  function append(start, end, highlight) {
    if (end - start > 0) {
      allChunks.push({
        start,
        end,
        highlight
      });
    }
  }
}
function defaultSanitize(string) {
  return string;
}
function escapeRegExpFn(string) {
  return string.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
}
var HighlightWords = {
  combineChunks,
  fillInChunks,
  findAll,
  findChunks: defaultFindChunks
};
var IDLE = "IDLE";
var SUGGESTING = "SUGGESTING";
var NAVIGATING = "NAVIGATING";
var INTERACTING = "INTERACTING";
var CLEAR = "CLEAR";
var CHANGE = "CHANGE";
var INITIAL_CHANGE = "INITIAL_CHANGE";
var NAVIGATE = "NAVIGATE";
var SELECT_WITH_KEYBOARD = "SELECT_WITH_KEYBOARD";
var SELECT_WITH_CLICK = "SELECT_WITH_CLICK";
var ESCAPE = "ESCAPE";
var BLUR = "BLUR";
var INTERACT = "INTERACT";
var FOCUS = "FOCUS";
var OPEN_WITH_BUTTON = "OPEN_WITH_BUTTON";
var OPEN_WITH_INPUT_CLICK = "OPEN_WITH_INPUT_CLICK";
var CLOSE_WITH_BUTTON = "CLOSE_WITH_BUTTON";
var stateChart = {
  initial: IDLE,
  states: {
    [IDLE]: {
      on: {
        [BLUR]: IDLE,
        [CLEAR]: IDLE,
        [CHANGE]: SUGGESTING,
        [INITIAL_CHANGE]: IDLE,
        [FOCUS]: SUGGESTING,
        [NAVIGATE]: NAVIGATING,
        [OPEN_WITH_BUTTON]: SUGGESTING,
        [OPEN_WITH_INPUT_CLICK]: SUGGESTING
      }
    },
    [SUGGESTING]: {
      on: {
        [CHANGE]: SUGGESTING,
        [FOCUS]: SUGGESTING,
        [NAVIGATE]: NAVIGATING,
        [CLEAR]: IDLE,
        [ESCAPE]: IDLE,
        [BLUR]: IDLE,
        [SELECT_WITH_CLICK]: IDLE,
        [INTERACT]: INTERACTING,
        [CLOSE_WITH_BUTTON]: IDLE
      }
    },
    [NAVIGATING]: {
      on: {
        [CHANGE]: SUGGESTING,
        [FOCUS]: SUGGESTING,
        [CLEAR]: IDLE,
        [BLUR]: IDLE,
        [ESCAPE]: IDLE,
        [NAVIGATE]: NAVIGATING,
        [SELECT_WITH_CLICK]: IDLE,
        [SELECT_WITH_KEYBOARD]: IDLE,
        [CLOSE_WITH_BUTTON]: IDLE,
        [INTERACT]: INTERACTING
      }
    },
    [INTERACTING]: {
      on: {
        [CLEAR]: IDLE,
        [CHANGE]: SUGGESTING,
        [FOCUS]: SUGGESTING,
        [BLUR]: IDLE,
        [ESCAPE]: IDLE,
        [NAVIGATE]: NAVIGATING,
        [CLOSE_WITH_BUTTON]: IDLE,
        [SELECT_WITH_CLICK]: IDLE
      }
    }
  }
};
var reducer = (data, event) => {
  let nextState = { ...data, lastEventType: event.type };
  switch (event.type) {
    case CHANGE:
    case INITIAL_CHANGE:
      return {
        ...nextState,
        navigationValue: null,
        value: event.value
      };
    case NAVIGATE:
    case OPEN_WITH_BUTTON:
    case OPEN_WITH_INPUT_CLICK:
      return {
        ...nextState,
        navigationValue: findNavigationValue(nextState, event)
      };
    case CLEAR:
      return {
        ...nextState,
        value: "",
        navigationValue: null
      };
    case BLUR:
    case ESCAPE:
      return {
        ...nextState,
        navigationValue: null
      };
    case SELECT_WITH_CLICK:
      return {
        ...nextState,
        value: event.isControlled ? data.value : event.value,
        navigationValue: null
      };
    case SELECT_WITH_KEYBOARD:
      return {
        ...nextState,
        value: event.isControlled ? data.value : data.navigationValue,
        navigationValue: null
      };
    case CLOSE_WITH_BUTTON:
      return {
        ...nextState,
        navigationValue: null
      };
    case INTERACT:
      return nextState;
    case FOCUS:
      return {
        ...nextState,
        navigationValue: findNavigationValue(nextState, event)
      };
    default:
      return nextState;
  }
};
function popoverIsExpanded(state) {
  return [SUGGESTING, NAVIGATING, INTERACTING].includes(state);
}
function findNavigationValue(stateData, event) {
  if (event.value) {
    return event.value;
  } else if (event.persistSelection) {
    return stateData.value;
  } else {
    return null;
  }
}
var ComboboxDescendantContext = createDescendantContext("ComboboxDescendantContext");
var ComboboxContext = createNamedContext("ComboboxContext", {});
var OptionContext = createNamedContext("OptionContext", {});
var Combobox = React7.forwardRef(({
  onSelect,
  openOnFocus = false,
  children,
  as: Comp = "div",
  "aria-label": ariaLabel,
  "aria-labelledby": ariaLabelledby,
  ...props2
}, forwardedRef) => {
  let [options, setOptions] = useDescendantsInit();
  let inputRef = React7.useRef();
  let popoverRef = React7.useRef();
  let buttonRef = React7.useRef();
  let autocompletePropRef = React7.useRef(false);
  let persistSelectionRef = React7.useRef(false);
  let defaultData = {
    value: "",
    navigationValue: null
  };
  let [state, data, transition] = useReducerMachine(stateChart, reducer, defaultData);
  useFocusManagement(data.lastEventType, inputRef);
  let id2 = useId(props2.id);
  let listboxId = id2 ? makeId("listbox", id2) : "listbox";
  let isControlledRef = React7.useRef(false);
  let isExpanded = popoverIsExpanded(state);
  let context = {
    ariaLabel,
    ariaLabelledby,
    autocompletePropRef,
    buttonRef,
    comboboxId: id2,
    data,
    inputRef,
    isExpanded,
    listboxId,
    onSelect: onSelect || noop,
    openOnFocus,
    persistSelectionRef,
    popoverRef,
    state,
    transition,
    isControlledRef
  };
  return React7.createElement(DescendantProvider, {
    context: ComboboxDescendantContext,
    items: options,
    set: setOptions
  }, React7.createElement(ComboboxContext.Provider, {
    value: context
  }, React7.createElement(Comp, {
    ...props2,
    "data-reach-combobox": "",
    "data-state": getDataState(state),
    "data-expanded": isExpanded || void 0,
    ref: forwardedRef
  }, isFunction(children) ? children({
    id: id2,
    isExpanded,
    navigationValue: data.navigationValue ?? null,
    state
  }) : children)));
});
Combobox.displayName = "Combobox";
var ComboboxInput = React7.forwardRef(({
  as: Comp = "input",
  selectOnClick = false,
  autocomplete = true,
  onClick,
  onChange,
  onKeyDown,
  onBlur,
  onFocus,
  value: controlledValue,
  ...props2
}, forwardedRef) => {
  let { current: initialControlledValue } = React7.useRef(controlledValue);
  let controlledValueChangedRef = React7.useRef(false);
  useUpdateEffect(() => {
    controlledValueChangedRef.current = true;
  }, [controlledValue]);
  let {
    data: { navigationValue, value, lastEventType },
    inputRef,
    state,
    transition,
    listboxId,
    autocompletePropRef,
    openOnFocus,
    isExpanded,
    ariaLabel,
    ariaLabelledby,
    persistSelectionRef,
    isControlledRef
  } = React7.useContext(ComboboxContext);
  let ref = useComposedRefs(inputRef, forwardedRef);
  let selectOnClickRef = React7.useRef(false);
  let handleKeyDown = useKeyDown();
  let handleBlur = useBlur();
  let isControlled = typeof controlledValue !== "undefined";
  let wasInitiallyControlled = typeof initialControlledValue !== "undefined";
  if (true) {
    if (!isControlled && wasInitiallyControlled) {
      console.warn("ComboboxInput is changing from controlled to uncontrolled. ComboboxInput should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled ComboboxInput for the lifetime of the component. Check the `value` prop being passed in.");
    }
    if (isControlled && !wasInitiallyControlled) {
      console.warn("ComboboxInput is changing from uncontrolled to controlled. ComboboxInput should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled ComboboxInput for the lifetime of the component. Check the `value` prop being passed in.");
    }
  }
  React7.useEffect(() => {
    isControlledRef.current = isControlled;
  }, [isControlled]);
  useIsomorphicLayoutEffect(() => {
    autocompletePropRef.current = autocomplete;
  }, [autocomplete, autocompletePropRef]);
  let handleValueChange = React7.useCallback((value2) => {
    if (value2.trim() === "") {
      transition(CLEAR, { isControlled });
    } else if (value2 === initialControlledValue && !controlledValueChangedRef.current) {
      transition(INITIAL_CHANGE, { value: value2 });
    } else {
      transition(CHANGE, { value: value2 });
    }
  }, [initialControlledValue, transition, isControlled]);
  React7.useEffect(() => {
    if (isControlled && controlledValue !== value && (controlledValue.trim() === "" ? (value || "").trim() !== "" : true)) {
      handleValueChange(controlledValue);
    }
  }, [controlledValue, handleValueChange, isControlled, value]);
  React7.useEffect(() => {
    var _a;
    let form = (_a = inputRef.current) == null ? void 0 : _a.form;
    if (!form)
      return;
    function handleReset(event) {
      transition(CLEAR, { isControlled });
    }
    form.addEventListener("reset", handleReset);
    return () => {
      form == null ? void 0 : form.removeEventListener("reset", handleReset);
    };
  }, [inputRef, isControlled, transition]);
  function handleChange(event) {
    let { value: value2 } = event.target;
    if (!isControlled) {
      handleValueChange(value2);
    }
  }
  function handleFocus() {
    if (selectOnClick) {
      selectOnClickRef.current = true;
    }
    if (openOnFocus && lastEventType !== SELECT_WITH_CLICK) {
      transition(FOCUS, {
        persistSelection: persistSelectionRef.current
      });
    }
  }
  function handleClick() {
    var _a;
    if (selectOnClickRef.current) {
      selectOnClickRef.current = false;
      (_a = inputRef.current) == null ? void 0 : _a.select();
    }
    if (openOnFocus && state === IDLE) {
      transition(OPEN_WITH_INPUT_CLICK);
    }
  }
  let inputValue = autocomplete && (state === NAVIGATING || state === INTERACTING) ? navigationValue || controlledValue || value : controlledValue || value;
  return React7.createElement(Comp, {
    "aria-activedescendant": navigationValue ? String(makeHash(navigationValue)) : void 0,
    "aria-autocomplete": "both",
    "aria-controls": listboxId,
    "aria-expanded": isExpanded,
    "aria-haspopup": "listbox",
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabel ? void 0 : ariaLabelledby,
    role: "combobox",
    ...props2,
    "data-reach-combobox-input": "",
    "data-state": getDataState(state),
    ref,
    onBlur: composeEventHandlers(onBlur, handleBlur),
    onChange: composeEventHandlers(onChange, handleChange),
    onClick: composeEventHandlers(onClick, handleClick),
    onFocus: composeEventHandlers(onFocus, handleFocus),
    onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown),
    value: inputValue || ""
  });
});
ComboboxInput.displayName = "ComboboxInput";
var ComboboxPopover = React7.forwardRef(({
  as: Comp = "div",
  children,
  portal = true,
  onKeyDown,
  onBlur,
  position = positionMatchWidth,
  ...props2
}, forwardedRef) => {
  let { popoverRef, inputRef, isExpanded, state } = React7.useContext(ComboboxContext);
  let ref = useComposedRefs(popoverRef, forwardedRef);
  let handleKeyDown = useKeyDown();
  let handleBlur = useBlur();
  let sharedProps = {
    "data-reach-combobox-popover": "",
    "data-state": getDataState(state),
    onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown),
    onBlur: composeEventHandlers(onBlur, handleBlur),
    hidden: !isExpanded,
    tabIndex: -1,
    children
  };
  return portal ? React7.createElement(Popover, {
    as: Comp,
    ...props2,
    ref,
    "data-expanded": isExpanded || void 0,
    position,
    targetRef: inputRef,
    unstable_skipInitialPortalRender: true,
    ...sharedProps
  }) : React7.createElement(Comp, {
    ref,
    ...props2,
    ...sharedProps
  });
});
ComboboxPopover.displayName = "ComboboxPopover";
var ComboboxList = React7.forwardRef(({
  persistSelection = false,
  as: Comp = "ul",
  ...props2
}, forwardedRef) => {
  let { persistSelectionRef, listboxId } = React7.useContext(ComboboxContext);
  if (persistSelection) {
    persistSelectionRef.current = true;
  }
  return React7.createElement(Comp, {
    role: "listbox",
    ...props2,
    ref: forwardedRef,
    "data-reach-combobox-list": "",
    id: listboxId
  });
});
ComboboxList.displayName = "ComboboxList";
var ComboboxOption = React7.forwardRef(({ as: Comp = "li", children, index: indexProp, value, onClick, ...props2 }, forwardedRef) => {
  let {
    onSelect,
    data: { navigationValue },
    transition,
    isControlledRef
  } = React7.useContext(ComboboxContext);
  let ownRef = React7.useRef(null);
  let [element, handleRefSet] = useStatefulRefValue(ownRef, null);
  let descendant = React7.useMemo(() => {
    return {
      element,
      value
    };
  }, [value, element]);
  let index = useDescendant(descendant, ComboboxDescendantContext, indexProp);
  let ref = useComposedRefs(forwardedRef, handleRefSet);
  let isActive = navigationValue === value;
  let handleClick = () => {
    onSelect && onSelect(value);
    transition(SELECT_WITH_CLICK, {
      value,
      isControlled: isControlledRef.current
    });
  };
  return React7.createElement(OptionContext.Provider, {
    value: { value, index }
  }, React7.createElement(Comp, {
    "aria-selected": isActive,
    role: "option",
    ...props2,
    "data-reach-combobox-option": "",
    ref,
    id: String(makeHash(value)),
    "data-highlighted": isActive ? "" : void 0,
    tabIndex: -1,
    onClick: composeEventHandlers(onClick, handleClick)
  }, children ? isFunction(children) ? children({ value, index }) : children : React7.createElement(ComboboxOptionText, null)));
});
ComboboxOption.displayName = "ComboboxOption";
function ComboboxOptionText() {
  let { value } = React7.useContext(OptionContext);
  let {
    data: { value: contextValue }
  } = React7.useContext(ComboboxContext);
  let results = React7.useMemo(() => HighlightWords.findAll({
    searchWords: escapeRegexp(contextValue || "").split(/\s+/),
    textToHighlight: value
  }), [contextValue, value]);
  return React7.createElement(React7.Fragment, null, results.length ? results.map((result, index) => {
    let str = value.slice(result.start, result.end);
    return React7.createElement("span", {
      key: index,
      "data-reach-combobox-option-text": "",
      "data-user-value": result.highlight ? true : void 0,
      "data-suggested-value": result.highlight ? void 0 : true
    }, str);
  }) : value);
}
ComboboxOptionText.displayName = "ComboboxOptionText";
var ComboboxButton = React7.forwardRef(({ as: Comp = "button", onClick, onKeyDown, ...props2 }, forwardedRef) => {
  let { transition, state, buttonRef, listboxId, isExpanded } = React7.useContext(ComboboxContext);
  let ref = useComposedRefs(buttonRef, forwardedRef);
  let handleKeyDown = useKeyDown();
  let handleClick = () => {
    if (state === IDLE) {
      transition(OPEN_WITH_BUTTON);
    } else {
      transition(CLOSE_WITH_BUTTON);
    }
  };
  return React7.createElement(Comp, {
    "aria-controls": listboxId,
    "aria-haspopup": "listbox",
    "aria-expanded": isExpanded,
    ...props2,
    "data-reach-combobox-button": "",
    ref,
    onClick: composeEventHandlers(onClick, handleClick),
    onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown)
  });
});
ComboboxButton.displayName = "ComboboxButton";
function useFocusManagement(lastEventType, inputRef) {
  useIsomorphicLayoutEffect(() => {
    var _a;
    if (lastEventType === NAVIGATE || lastEventType === ESCAPE || lastEventType === SELECT_WITH_CLICK || lastEventType === OPEN_WITH_BUTTON) {
      (_a = inputRef.current) == null ? void 0 : _a.focus();
    }
  }, [inputRef, lastEventType]);
}
function useKeyDown() {
  let {
    data: { navigationValue },
    onSelect,
    state,
    transition,
    autocompletePropRef,
    persistSelectionRef,
    inputRef,
    isControlledRef
  } = React7.useContext(ComboboxContext);
  let options = useDescendants(ComboboxDescendantContext);
  return function handleKeyDown(event) {
    var _a;
    let index = options.findIndex(({ value }) => value === navigationValue);
    function getNextOption() {
      let atBottom = index === options.length - 1;
      if (atBottom) {
        if (autocompletePropRef.current) {
          return null;
        } else {
          return getFirstOption();
        }
      } else {
        return options[(index + 1) % options.length];
      }
    }
    function getPreviousOption() {
      let atTop = index === 0;
      if (atTop) {
        if (autocompletePropRef.current) {
          return null;
        } else {
          return getLastOption();
        }
      } else if (index === -1) {
        return getLastOption();
      } else {
        return options[(index - 1 + options.length) % options.length];
      }
    }
    function getFirstOption() {
      return options[0];
    }
    function getLastOption() {
      return options[options.length - 1];
    }
    let textareaHasMultilineValue = ((_a = inputRef.current) == null ? void 0 : _a.tagName.toUpperCase()) === "TEXTAREA" && inputRef.current.value.includes(`
`);
    switch (event.key) {
      case "ArrowDown":
        if (!options || !options.length) {
          return;
        }
        if (state === IDLE) {
          if (textareaHasMultilineValue) {
            return;
          }
          event.preventDefault();
          transition(NAVIGATE, {
            persistSelection: persistSelectionRef.current
          });
        } else {
          event.preventDefault();
          let next = getNextOption();
          transition(NAVIGATE, { value: next ? next.value : null });
        }
        break;
      case "ArrowUp":
        if (!options || !options.length) {
          return;
        }
        if (state === IDLE) {
          if (textareaHasMultilineValue) {
            return;
          }
          event.preventDefault();
          transition(NAVIGATE, {
            persistSelection: persistSelectionRef.current
          });
        } else {
          event.preventDefault();
          let prev = getPreviousOption();
          transition(NAVIGATE, { value: prev ? prev.value : null });
        }
        break;
      case "Home":
      case "PageUp":
        event.preventDefault();
        if (!options || options.length === 0) {
          return;
        }
        if (state === IDLE) {
          transition(NAVIGATE);
        } else {
          transition(NAVIGATE, { value: getFirstOption().value });
        }
        break;
      case "End":
      case "PageDown":
        event.preventDefault();
        if (!options || options.length === 0) {
          return;
        }
        if (state === IDLE) {
          transition(NAVIGATE);
        } else {
          transition(NAVIGATE, { value: getLastOption().value });
        }
        break;
      case "Escape":
        if (state !== IDLE) {
          transition(ESCAPE);
        }
        break;
      case "Enter":
        if (state === NAVIGATING && navigationValue !== null) {
          event.preventDefault();
          onSelect && onSelect(navigationValue);
          transition(SELECT_WITH_KEYBOARD, {
            isControlled: isControlledRef.current
          });
        }
        break;
    }
  };
}
function useBlur() {
  let { state, transition, popoverRef, inputRef, buttonRef } = React7.useContext(ComboboxContext);
  return function handleBlur(event) {
    let popover = popoverRef.current;
    let input = inputRef.current;
    let button = buttonRef.current;
    let activeElement = event.relatedTarget;
    if (activeElement !== input && activeElement !== button && popover) {
      if (popover.contains(activeElement)) {
        if (state !== INTERACTING) {
          transition(INTERACT);
        }
      } else {
        transition(BLUR);
      }
    }
  };
}
function useReducerMachine(chart, reducer2, initialData) {
  let [state, setState] = React7.useState(chart.initial);
  let [data, dispatch] = React7.useReducer(reducer2, initialData);
  let transition = (event, payload = {}) => {
    let currentState = chart.states[state];
    let nextState = currentState && currentState.on[event];
    if (nextState) {
      dispatch({ type: event, state, nextState: state, ...payload });
      setState(nextState);
      return;
    }
  };
  return [state, data, transition];
}
function makeHash(str) {
  let hash = 0;
  if (str.length === 0) {
    return hash;
  }
  for (let i = 0; i < str.length; i++) {
    hash = (hash << 5) - hash + str.charCodeAt(i);
    hash = hash & hash;
  }
  return hash;
}
function getDataState(state) {
  return state.toLowerCase();
}
function escapeRegexp(str) {
  return String(str).replace(/([.*+?=^!:${}()|[\]/\\])/g, "\\$1");
}
function useComboboxContext() {
  let { isExpanded, comboboxId, data, state } = React7.useContext(ComboboxContext);
  let { navigationValue } = data;
  return React7.useMemo(() => ({
    id: comboboxId,
    isExpanded,
    navigationValue: navigationValue ?? null,
    state
  }), [comboboxId, isExpanded, navigationValue, state]);
}
function useComboboxOptionContext() {
  let { value, index } = React7.useContext(OptionContext);
  return React7.useMemo(() => ({
    value,
    index
  }), [value, index]);
}
export {
  Combobox,
  ComboboxButton,
  ComboboxInput,
  ComboboxList,
  ComboboxOption,
  ComboboxOptionText,
  ComboboxPopover,
  escapeRegexp,
  useKeyDown as unstable_useKeyDown,
  useComboboxContext,
  useComboboxOptionContext
};
/*! Bundled license information:

@reach/utils/dist/reach-utils.mjs:
  (**
    * @reach/utils v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)

@reach/descendants/dist/reach-descendants.mjs:
  (**
    * @reach/descendants v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)

@reach/auto-id/dist/reach-auto-id.mjs:
  (**
    * @reach/auto-id v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)

@reach/portal/dist/reach-portal.mjs:
  (**
    * @reach/portal v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)

@reach/rect/dist/reach-rect.mjs:
  (**
    * @reach/rect v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 5.3.3
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

@reach/popover/dist/reach-popover.mjs:
  (**
    * @reach/popover v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)

@reach/combobox/dist/reach-combobox.mjs:
  (**
    * @reach/combobox v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)
*/
//# sourceMappingURL=@reach_combobox.js.map
